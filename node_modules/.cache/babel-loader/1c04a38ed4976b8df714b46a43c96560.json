{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/marcos/\\xC1rea de Trabalho/Web Projects/snake/src/App.js\";\nimport React, { Component } from 'react';\nimport Menu from './components/Menu';\nimport Food from './components/Food';\nimport Part from './components/Part';\nimport Score from './components/Score';\nconst start = {\n  active: true,\n  speed: 120,\n  // ms\n  direction: \"right\",\n  snake: [[50, 70], [60, 70], [70, 70], [80, 70]],\n  // Start with 4 block snake\n  food: [200, 70],\n  score: 0,\n  high_score: localStorage.getItem(\"high_score\")\n};\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.startStop = manual => {\n      let active = this.state.active; // console.log(localStorage.getItem('high_score'));\n\n      if (manual) {\n        this.setState({\n          active: !active\n        });\n      } // This is reading the previous state, before manual switched it\n\n\n      if (!active) {\n        this.interval = setInterval(() => this.updateSnake(), this.state.speed);\n      } else {\n        clearInterval(this.interval);\n        let high_score = this.state.high_score;\n\n        if (this.state.score > high_score || high_score === null) {\n          high_score = this.state.score;\n        }\n\n        localStorage.setItem(\"high_score\", high_score);\n        this.setState({\n          active: false,\n          speed: 120,\n          // ms\n          direction: \"right\",\n          snake: [[50, 70], [60, 70], [70, 70], [80, 70]],\n          // Start with 4 block snake\n          food: [200, 70],\n          score: 0,\n          high_score: high_score\n        });\n      }\n    };\n\n    this.handleKeys = event => {\n      let currentD = this.state.direction;\n      let active = this.state.active; //  console.log(event.keyCode);\n\n      if (event.keyCode === 13) {\n        this.startStop(true);\n      }\n\n      if (event.keyCode === 65 && currentD !== \"right\") {\n        this.setState({\n          direction: \"left\"\n        });\n        this.swapClass();\n      }\n\n      if (event.keyCode === 68 && currentD !== \"left\") {\n        this.setState({\n          direction: \"right\"\n        });\n        this.swapClass();\n      }\n\n      if (event.keyCode === 87 && currentD !== \"down\") {\n        this.setState({\n          direction: \"up\"\n        });\n        this.swapClass();\n      }\n\n      if (event.keyCode === 83 && currentD !== \"up\") {\n        this.setState({\n          direction: \"down\"\n        });\n        this.swapClass();\n      }\n    };\n\n    this.speedUp = () => {\n      let speed = this.state.speed; // if (speed > 50) {\n      //   speed -= 2;\n      // }\n\n      speed -= 2;\n      clearInterval(this.interval);\n      this.interval = setInterval(() => this.updateSnake(), speed);\n      this.setState({\n        speed: speed\n      });\n    };\n\n    this.swapClass = () => {\n      var root = document.getElementById(\"root\");\n      root.className = \"\";\n      root.className = this.state.direction;\n    };\n\n    this.state = start;\n  }\n\n  componentDidMount() {\n    this.swapClass();\n    document.addEventListener(\"keydown\", this.handleKeys, false);\n\n    if (this.state.active) {\n      this.startStop(false);\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // When the state changes, check if we've reached a % 5 milestone\n    // Run speedUp once, but not again until next time (state updates each time snake moves)\n    let score = this.state.score;\n\n    if (score > 0 && score !== prevState.score) {\n      this.speedUp();\n    }\n\n    document.addEventListener(\"keydown\", this.handleKeys, false);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  updateSnake() {\n    var direction = this.state.direction;\n    var currentSnake = this.state.snake;\n    var snakeHead = currentSnake[currentSnake.length - 1];\n    var newHead = [];\n    var target = this.state.food;\n\n    switch (direction) {\n      case \"up\":\n        newHead = [snakeHead[0], snakeHead[1] - 10];\n        break;\n\n      case \"right\":\n        newHead = [snakeHead[0] + 10, snakeHead[1]];\n        break;\n\n      case \"down\":\n        newHead = [snakeHead[0], snakeHead[1] + 10];\n        break;\n\n      case \"left\":\n        newHead = [snakeHead[0] - 10, snakeHead[1]];\n        break;\n\n      default:\n        newHead = [snakeHead[0], snakeHead[1]];\n    }\n\n    currentSnake.push(newHead);\n    currentSnake.forEach((val, i, array) => {\n      // As long as its not checking against itself...\n      if (i !== array.length - 1) {\n        // Check if its colluding with its body\n        if (val.toString() === newHead.toString()) {\n          // Head has collided with body\n          //   console.log('collide');\n          this.startStop(true);\n        }\n      }\n    }); // collusion detection\n\n    if (newHead[0] > 390 || newHead[0] < 0 || newHead[1] > 320 || newHead[1] < 30) {\n      // Enable this is you want the wall collusion rule\n      // this.startStop(true);\n      // This is teleporting the snake through the walls\n      let teleHead = currentSnake[currentSnake.length - 1];\n\n      if (newHead[0] > 390) {\n        teleHead[0] = teleHead[0] - 400;\n        currentSnake.shift();\n      }\n\n      if (newHead[0] < 0) {\n        teleHead[0] = teleHead[0] + 400;\n        currentSnake.shift();\n      }\n\n      if (newHead[1] > 320) {\n        teleHead[1] = teleHead[1] - 300;\n        currentSnake.shift();\n      }\n\n      if (newHead[1] < 30) {\n        teleHead[1] = teleHead[1] + 300;\n        currentSnake.shift();\n      }\n    } else {\n      // If food is eaten\n      if (newHead[0] === target[0] && newHead[1] === target[1]) {\n        let posX = Math.floor(Math.random() * (380 - 10 + 1)) + 10;\n        let posY = Math.floor(Math.random() * (280 - 40 + 1)) + 40;\n        posX = Math.ceil(posX / 10) * 10;\n        posY = Math.ceil(posY / 10) * 10;\n        this.setState(prevState => ({\n          snake: currentSnake,\n          food: [posX, posY],\n          score: prevState.score + 1\n        }));\n      } else {\n        currentSnake.shift();\n\n        if (this.state.active) {\n          this.setState({\n            snake: currentSnake\n          });\n        }\n      }\n    }\n  }\n\n  render() {\n    var theSnake = this.state.snake;\n    var food = this.state.food;\n    return /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(Menu, {\n        active: this.state.active\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 210,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Score, {\n        score: this.state.score,\n        highScore: this.state.high_score\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 9\n      }, this), theSnake.map((val, i) => /*#__PURE__*/_jsxDEV(Part, {\n        transition: this.state.speed,\n        direction: this.state.direction,\n        top: val[1],\n        left: val[0]\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 213,\n        columnNumber: 11\n      }, this)), /*#__PURE__*/_jsxDEV(Food, {\n        top: food[1],\n        left: food[0]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/home/marcos/Ãrea de Trabalho/Web Projects/snake/src/App.js"],"names":["React","Component","Menu","Food","Part","Score","start","active","speed","direction","snake","food","score","high_score","localStorage","getItem","App","constructor","props","startStop","manual","state","setState","interval","setInterval","updateSnake","clearInterval","setItem","handleKeys","event","currentD","keyCode","swapClass","speedUp","root","document","getElementById","className","componentDidMount","addEventListener","componentDidUpdate","prevProps","prevState","componentWillUnmount","currentSnake","snakeHead","length","newHead","target","push","forEach","val","i","array","toString","teleHead","shift","posX","Math","floor","random","posY","ceil","render","theSnake","map"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AAEA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,OAAOC,KAAP,MAAkB,oBAAlB;AAEA,MAAMC,KAAK,GAAG;AACZC,EAAAA,MAAM,EAAE,IADI;AAEZC,EAAAA,KAAK,EAAE,GAFK;AAEA;AACZC,EAAAA,SAAS,EAAE,OAHC;AAIZC,EAAAA,KAAK,EAAE,CAAC,CAAC,EAAD,EAAK,EAAL,CAAD,EAAW,CAAC,EAAD,EAAK,EAAL,CAAX,EAAqB,CAAC,EAAD,EAAK,EAAL,CAArB,EAA+B,CAAC,EAAD,EAAK,EAAL,CAA/B,CAJK;AAIqC;AACjDC,EAAAA,IAAI,EAAE,CAAC,GAAD,EAAM,EAAN,CALM;AAMZC,EAAAA,KAAK,EAAE,CANK;AAOZC,EAAAA,UAAU,EAAEC,YAAY,CAACC,OAAb,CAAqB,YAArB;AAPA,CAAd;;AAUA,MAAMC,GAAN,SAAkBf,SAAlB,CAA4B;AAC1BgB,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;;AADiB,SA6BnBC,SA7BmB,GA6BPC,MAAM,IAAI;AACpB,UAAIb,MAAM,GAAG,KAAKc,KAAL,CAAWd,MAAxB,CADoB,CAEpB;;AACA,UAAIa,MAAJ,EAAY;AACV,aAAKE,QAAL,CAAc;AAAEf,UAAAA,MAAM,EAAE,CAACA;AAAX,SAAd;AACD,OALmB,CAMpB;;;AACA,UAAI,CAACA,MAAL,EAAa;AACX,aAAKgB,QAAL,GAAgBC,WAAW,CAAC,MAAM,KAAKC,WAAL,EAAP,EAA2B,KAAKJ,KAAL,CAAWb,KAAtC,CAA3B;AACD,OAFD,MAGK;AACHkB,QAAAA,aAAa,CAAC,KAAKH,QAAN,CAAb;AACA,YAAIV,UAAU,GAAG,KAAKQ,KAAL,CAAWR,UAA5B;;AACA,YAAI,KAAKQ,KAAL,CAAWT,KAAX,GAAmBC,UAAnB,IAAiCA,UAAU,KAAK,IAApD,EAA0D;AACxDA,UAAAA,UAAU,GAAG,KAAKQ,KAAL,CAAWT,KAAxB;AACD;;AACDE,QAAAA,YAAY,CAACa,OAAb,CAAqB,YAArB,EAAmCd,UAAnC;AACA,aAAKS,QAAL,CAAc;AACZf,UAAAA,MAAM,EAAE,KADI;AAEZC,UAAAA,KAAK,EAAE,GAFK;AAEA;AACZC,UAAAA,SAAS,EAAE,OAHC;AAIZC,UAAAA,KAAK,EAAE,CAAC,CAAC,EAAD,EAAK,EAAL,CAAD,EAAW,CAAC,EAAD,EAAK,EAAL,CAAX,EAAqB,CAAC,EAAD,EAAK,EAAL,CAArB,EAA+B,CAAC,EAAD,EAAK,EAAL,CAA/B,CAJK;AAIqC;AACjDC,UAAAA,IAAI,EAAE,CAAC,GAAD,EAAM,EAAN,CALM;AAMZC,UAAAA,KAAK,EAAE,CANK;AAOZC,UAAAA,UAAU,EAAEA;AAPA,SAAd;AASD;AACF,KAxDkB;;AAAA,SA+InBe,UA/ImB,GA+INC,KAAK,IAAI;AACpB,UAAIC,QAAQ,GAAG,KAAKT,KAAL,CAAWZ,SAA1B;AACA,UAAIF,MAAM,GAAG,KAAKc,KAAL,CAAWd,MAAxB,CAFoB,CAGpB;;AACA,UAAIsB,KAAK,CAACE,OAAN,KAAkB,EAAtB,EAA0B;AACxB,aAAKZ,SAAL,CAAe,IAAf;AACD;;AACD,UAAIU,KAAK,CAACE,OAAN,KAAkB,EAAlB,IAAwBD,QAAQ,KAAK,OAAzC,EAAkD;AAChD,aAAKR,QAAL,CAAc;AAAEb,UAAAA,SAAS,EAAE;AAAb,SAAd;AACA,aAAKuB,SAAL;AACD;;AACD,UAAIH,KAAK,CAACE,OAAN,KAAkB,EAAlB,IAAwBD,QAAQ,KAAK,MAAzC,EAAiD;AAC/C,aAAKR,QAAL,CAAc;AAAEb,UAAAA,SAAS,EAAE;AAAb,SAAd;AACA,aAAKuB,SAAL;AACD;;AACD,UAAIH,KAAK,CAACE,OAAN,KAAkB,EAAlB,IAAwBD,QAAQ,KAAK,MAAzC,EAAiD;AAC/C,aAAKR,QAAL,CAAc;AAAEb,UAAAA,SAAS,EAAE;AAAb,SAAd;AACA,aAAKuB,SAAL;AACD;;AACD,UAAIH,KAAK,CAACE,OAAN,KAAkB,EAAlB,IAAwBD,QAAQ,KAAK,IAAzC,EAA+C;AAC7C,aAAKR,QAAL,CAAc;AAAEb,UAAAA,SAAS,EAAE;AAAb,SAAd;AACA,aAAKuB,SAAL;AACD;AACF,KAtKkB;;AAAA,SAwKnBC,OAxKmB,GAwKT,MAAM;AACd,UAAIzB,KAAK,GAAG,KAAKa,KAAL,CAAWb,KAAvB,CADc,CAEd;AACA;AACA;;AACAA,MAAAA,KAAK,IAAI,CAAT;AACAkB,MAAAA,aAAa,CAAC,KAAKH,QAAN,CAAb;AACA,WAAKA,QAAL,GAAgBC,WAAW,CAAC,MAAM,KAAKC,WAAL,EAAP,EAA2BjB,KAA3B,CAA3B;AACA,WAAKc,QAAL,CAAc;AAAEd,QAAAA,KAAK,EAAEA;AAAT,OAAd;AACD,KAjLkB;;AAAA,SAoLnBwB,SApLmB,GAoLP,MAAM;AAChB,UAAIE,IAAI,GAAGC,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAAX;AACAF,MAAAA,IAAI,CAACG,SAAL,GAAiB,EAAjB;AACAH,MAAAA,IAAI,CAACG,SAAL,GAAiB,KAAKhB,KAAL,CAAWZ,SAA5B;AACD,KAxLkB;;AAEjB,SAAKY,KAAL,GAAaf,KAAb;AACD;;AAEDgC,EAAAA,iBAAiB,GAAG;AAClB,SAAKN,SAAL;AACAG,IAAAA,QAAQ,CAACI,gBAAT,CAA0B,SAA1B,EAAqC,KAAKX,UAA1C,EAAsD,KAAtD;;AACA,QAAI,KAAKP,KAAL,CAAWd,MAAf,EAAuB;AACrB,WAAKY,SAAL,CAAe,KAAf;AACD;AACF;;AAEDqB,EAAAA,kBAAkB,CAACC,SAAD,EAAYC,SAAZ,EAAuB;AACvC;AACA;AACA,QAAI9B,KAAK,GAAG,KAAKS,KAAL,CAAWT,KAAvB;;AACA,QACJA,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAK8B,SAAS,CAAC9B,KAD7B,EACoC;AAClC,WAAKqB,OAAL;AACD;;AAEDE,IAAAA,QAAQ,CAACI,gBAAT,CAA0B,SAA1B,EAAqC,KAAKX,UAA1C,EAAsD,KAAtD;AACD;;AAEDe,EAAAA,oBAAoB,GAAG;AACrBjB,IAAAA,aAAa,CAAC,KAAKH,QAAN,CAAb;AACD;;AA+BDE,EAAAA,WAAW,GAAG;AACZ,QAAIhB,SAAS,GAAG,KAAKY,KAAL,CAAWZ,SAA3B;AACA,QAAImC,YAAY,GAAG,KAAKvB,KAAL,CAAWX,KAA9B;AACA,QAAImC,SAAS,GAAGD,YAAY,CAACA,YAAY,CAACE,MAAb,GAAsB,CAAvB,CAA5B;AACA,QAAIC,OAAO,GAAG,EAAd;AACA,QAAIC,MAAM,GAAG,KAAK3B,KAAL,CAAWV,IAAxB;;AACA,YAAQF,SAAR;AACE,WAAK,IAAL;AACEsC,QAAAA,OAAO,GAAG,CAACF,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAT,GAAe,EAA9B,CAAV;AACA;;AACF,WAAK,OAAL;AACEE,QAAAA,OAAO,GAAG,CAACF,SAAS,CAAC,CAAD,CAAT,GAAe,EAAhB,EAAoBA,SAAS,CAAC,CAAD,CAA7B,CAAV;AACA;;AACF,WAAK,MAAL;AACEE,QAAAA,OAAO,GAAG,CAACF,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAT,GAAe,EAA9B,CAAV;AACA;;AACF,WAAK,MAAL;AACEE,QAAAA,OAAO,GAAG,CAACF,SAAS,CAAC,CAAD,CAAT,GAAe,EAAhB,EAAoBA,SAAS,CAAC,CAAD,CAA7B,CAAV;AACA;;AACF;AACEE,QAAAA,OAAO,GAAG,CAACF,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAxB,CAAV;AAdJ;;AAgBAD,IAAAA,YAAY,CAACK,IAAb,CAAkBF,OAAlB;AAEAH,IAAAA,YAAY,CAACM,OAAb,CAAqB,CAACC,GAAD,EAAMC,CAAN,EAASC,KAAT,KAAmB;AACtC;AACA,UAAID,CAAC,KAAKC,KAAK,CAACP,MAAN,GAAe,CAAzB,EAA4B;AAC1B;AACA,YAAIK,GAAG,CAACG,QAAJ,OAAmBP,OAAO,CAACO,QAAR,EAAvB,EAA2C;AACzC;AACA;AACA,eAAKnC,SAAL,CAAe,IAAf;AACD;AACF;AACF,KAVD,EAxBY,CAoCZ;;AACA,QACE4B,OAAO,CAAC,CAAD,CAAP,GAAa,GAAb,IACAA,OAAO,CAAC,CAAD,CAAP,GAAa,CADb,IAEAA,OAAO,CAAC,CAAD,CAAP,GAAa,GAFb,IAGAA,OAAO,CAAC,CAAD,CAAP,GAAa,EAJf,EAKE;AACA;AACA;AAEA;AACA,UAAIQ,QAAQ,GAAGX,YAAY,CAACA,YAAY,CAACE,MAAb,GAAsB,CAAvB,CAA3B;;AACA,UAAIC,OAAO,CAAC,CAAD,CAAP,GAAa,GAAjB,EAAsB;AACpBQ,QAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAR,GAAc,GAA5B;AACAX,QAAAA,YAAY,CAACY,KAAb;AACD;;AACD,UAAIT,OAAO,CAAC,CAAD,CAAP,GAAa,CAAjB,EAAoB;AAClBQ,QAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAR,GAAc,GAA5B;AACAX,QAAAA,YAAY,CAACY,KAAb;AACD;;AACD,UAAIT,OAAO,CAAC,CAAD,CAAP,GAAa,GAAjB,EAAsB;AACpBQ,QAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAR,GAAc,GAA5B;AACAX,QAAAA,YAAY,CAACY,KAAb;AACD;;AACD,UAAIT,OAAO,CAAC,CAAD,CAAP,GAAa,EAAjB,EAAqB;AACnBQ,QAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAR,GAAc,GAA5B;AACAX,QAAAA,YAAY,CAACY,KAAb;AACD;AACF,KA3BD,MA2BO;AACL;AACA,UAAIT,OAAO,CAAC,CAAD,CAAP,KAAeC,MAAM,CAAC,CAAD,CAArB,IAA4BD,OAAO,CAAC,CAAD,CAAP,KAAeC,MAAM,CAAC,CAAD,CAArD,EAA0D;AACxD,YAAIS,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiB,MAAM,EAAN,GAAW,CAA5B,CAAX,IAA6C,EAAxD;AACA,YAAIC,IAAI,GAAGH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiB,MAAM,EAAN,GAAW,CAA5B,CAAX,IAA6C,EAAxD;AACAH,QAAAA,IAAI,GAAGC,IAAI,CAACI,IAAL,CAAUL,IAAI,GAAG,EAAjB,IAAuB,EAA9B;AACAI,QAAAA,IAAI,GAAGH,IAAI,CAACI,IAAL,CAAUD,IAAI,GAAG,EAAjB,IAAuB,EAA9B;AACA,aAAKvC,QAAL,CAAcoB,SAAS,KAAK;AAC1BhC,UAAAA,KAAK,EAAEkC,YADmB;AAE1BjC,UAAAA,IAAI,EAAE,CAAC8C,IAAD,EAAOI,IAAP,CAFoB;AAG1BjD,UAAAA,KAAK,EAAE8B,SAAS,CAAC9B,KAAV,GAAkB;AAHC,SAAL,CAAvB;AAKD,OAVD,MAUO;AACLgC,QAAAA,YAAY,CAACY,KAAb;;AACA,YAAI,KAAKnC,KAAL,CAAWd,MAAf,EAAuB;AACrB,eAAKe,QAAL,CAAc;AAAEZ,YAAAA,KAAK,EAAEkC;AAAT,WAAd;AACD;AACF;AACF;AACF;;AA6CDmB,EAAAA,MAAM,GAAG;AACP,QAAIC,QAAQ,GAAG,KAAK3C,KAAL,CAAWX,KAA1B;AACA,QAAIC,IAAI,GAAG,KAAKU,KAAL,CAAWV,IAAtB;AACA,wBACE,QAAC,KAAD,CAAO,QAAP;AAAA,8BACE,QAAC,IAAD;AAAM,QAAA,MAAM,EAAE,KAAKU,KAAL,CAAWd;AAAzB;AAAA;AAAA;AAAA;AAAA,cADF,eAEE,QAAC,KAAD;AAAO,QAAA,KAAK,EAAE,KAAKc,KAAL,CAAWT,KAAzB;AAAgC,QAAA,SAAS,EAAE,KAAKS,KAAL,CAAWR;AAAtD;AAAA;AAAA;AAAA;AAAA,cAFF,EAGGmD,QAAQ,CAACC,GAAT,CAAa,CAACd,GAAD,EAAMC,CAAN,kBACZ,QAAC,IAAD;AAEE,QAAA,UAAU,EAAE,KAAK/B,KAAL,CAAWb,KAFzB;AAGE,QAAA,SAAS,EAAE,KAAKa,KAAL,CAAWZ,SAHxB;AAIE,QAAA,GAAG,EAAE0C,GAAG,CAAC,CAAD,CAJV;AAKE,QAAA,IAAI,EAAEA,GAAG,CAAC,CAAD;AALX,SACOC,CADP;AAAA;AAAA;AAAA;AAAA,cADD,CAHH,eAYE,QAAC,IAAD;AAAM,QAAA,GAAG,EAAEzC,IAAI,CAAC,CAAD,CAAf;AAAoB,QAAA,IAAI,EAAEA,IAAI,CAAC,CAAD;AAA9B;AAAA;AAAA;AAAA;AAAA,cAZF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAgBD;;AA9MyB;;AAiN5B,eAAeK,GAAf","sourcesContent":["import React, { Component } from 'react'\n\nimport Menu from './components/Menu';\nimport Food from './components/Food';\nimport Part from './components/Part';\nimport Score from './components/Score';\n\nconst start = {\n  active: true,\n  speed: 120, // ms\n  direction: \"right\",\n  snake: [[50, 70], [60, 70], [70, 70], [80, 70]], // Start with 4 block snake\n  food: [200, 70],\n  score: 0,\n  high_score: localStorage.getItem(\"high_score\")\n};\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = start;\n  }\n\n  componentDidMount() {\n    this.swapClass();\n    document.addEventListener(\"keydown\", this.handleKeys, false);\n    if (this.state.active) {\n      this.startStop(false);\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // When the state changes, check if we've reached a % 5 milestone\n    // Run speedUp once, but not again until next time (state updates each time snake moves)\n    let score = this.state.score;\n    if (\nscore > 0 && score !== prevState.score) {\n      this.speedUp();\n    }\n\n    document.addEventListener(\"keydown\", this.handleKeys, false);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  startStop = manual => {\n    let active = this.state.active;\n    // console.log(localStorage.getItem('high_score'));\n    if (manual) {\n      this.setState({ active: !active });\n    }\n    // This is reading the previous state, before manual switched it\n    if (!active) {\n      this.interval = setInterval(() => this.updateSnake(), this.state.speed);\n    } \n    else {\n      clearInterval(this.interval);\n      let high_score = this.state.high_score;\n      if (this.state.score > high_score || high_score === null) {\n        high_score = this.state.score;\n      }\n      localStorage.setItem(\"high_score\", high_score);\n      this.setState({\n        active: false,\n        speed: 120, // ms\n        direction: \"right\",\n        snake: [[50, 70], [60, 70], [70, 70], [80, 70]], // Start with 4 block snake\n        food: [200, 70],\n        score: 0,\n        high_score: high_score\n      });\n    }\n  };\n\n  updateSnake() {\n    var direction = this.state.direction;\n    var currentSnake = this.state.snake;\n    var snakeHead = currentSnake[currentSnake.length - 1];\n    var newHead = [];\n    var target = this.state.food;\n    switch (direction) {\n      case \"up\":\n        newHead = [snakeHead[0], snakeHead[1] - 10];\n        break;\n      case \"right\":\n        newHead = [snakeHead[0] + 10, snakeHead[1]];\n        break;\n      case \"down\":\n        newHead = [snakeHead[0], snakeHead[1] + 10];\n        break;\n      case \"left\":\n        newHead = [snakeHead[0] - 10, snakeHead[1]];\n        break;\n      default:\n        newHead = [snakeHead[0], snakeHead[1]];\n    }\n    currentSnake.push(newHead);\n\n    currentSnake.forEach((val, i, array) => {\n      // As long as its not checking against itself...\n      if (i !== array.length - 1) {\n        // Check if its colluding with its body\n        if (val.toString() === newHead.toString()) {\n          // Head has collided with body\n          //   console.log('collide');\n          this.startStop(true);\n        }\n      }\n    });\n\n    // collusion detection\n    if (\n      newHead[0] > 390 ||\n      newHead[0] < 0 ||\n      newHead[1] > 320 ||\n      newHead[1] < 30\n    ) {\n      // Enable this is you want the wall collusion rule\n      // this.startStop(true);\n\n      // This is teleporting the snake through the walls\n      let teleHead = currentSnake[currentSnake.length - 1];\n      if (newHead[0] > 390) {\n        teleHead[0] = teleHead[0] - 400;\n        currentSnake.shift();\n      }\n      if (newHead[0] < 0) {\n        teleHead[0] = teleHead[0] + 400;\n        currentSnake.shift();\n      }\n      if (newHead[1] > 320) {\n        teleHead[1] = teleHead[1] - 300;\n        currentSnake.shift();\n      }\n      if (newHead[1] < 30) {\n        teleHead[1] = teleHead[1] + 300;\n        currentSnake.shift();\n      }\n    } else {\n      // If food is eaten\n      if (newHead[0] === target[0] && newHead[1] === target[1]) {\n        let posX = Math.floor(Math.random() * (380 - 10 + 1)) + 10;\n        let posY = Math.floor(Math.random() * (280 - 40 + 1)) + 40;\n        posX = Math.ceil(posX / 10) * 10;\n        posY = Math.ceil(posY / 10) * 10;\n        this.setState(prevState => ({\n          snake: currentSnake,\n          food: [posX, posY],\n          score: prevState.score + 1\n        }));\n      } else {\n        currentSnake.shift();\n        if (this.state.active) {\n          this.setState({ snake: currentSnake });\n        }\n      }\n    }\n  }\n\n  handleKeys = event => {\n    let currentD = this.state.direction;\n    let active = this.state.active;\n    //  console.log(event.keyCode);\n    if (event.keyCode === 13) {\n      this.startStop(true);\n    }\n    if (event.keyCode === 65 && currentD !== \"right\") {\n      this.setState({ direction: \"left\" });\n      this.swapClass();\n    }\n    if (event.keyCode === 68 && currentD !== \"left\") {\n      this.setState({ direction: \"right\" });\n      this.swapClass();\n    }\n    if (event.keyCode === 87 && currentD !== \"down\") {\n      this.setState({ direction: \"up\" });\n      this.swapClass();\n    }\n    if (event.keyCode === 83 && currentD !== \"up\") {\n      this.setState({ direction: \"down\" });\n      this.swapClass();\n    }\n  };\n\n  speedUp = () => {\n    let speed = this.state.speed;\n    // if (speed > 50) {\n    //   speed -= 2;\n    // }\n    speed -= 2;\n    clearInterval(this.interval);\n    this.interval = setInterval(() => this.updateSnake(), speed);\n    this.setState({ speed: speed });\n  };\n\n  // #root takes on the class of the direction, good for styling opportunities?\n  swapClass = () => {\n    var root = document.getElementById(\"root\");\n    root.className = \"\";\n    root.className = this.state.direction;\n  };\n\n  render() {\n    var theSnake = this.state.snake;\n    var food = this.state.food;\n    return (\n      <React.Fragment>\n        <Menu active={this.state.active} />\n        <Score score={this.state.score} highScore={this.state.high_score} />\n        {theSnake.map((val, i) => (\n          <Part\n            key={i}\n            transition={this.state.speed}\n            direction={this.state.direction}\n            top={val[1]}\n            left={val[0]}\n          />\n        ))}\n        <Food top={food[1]} left={food[0]} />\n      </React.Fragment>\n    );\n  }\n}\n\nexport default App;"]},"metadata":{},"sourceType":"module"}